# app/services/run_status_service.py

from datetime import datetime
from pymongo.database import Database
from app.model.enums import StepName, StepStatus
from app.utils.logger import setup_logger

logger = setup_logger(__name__)

class RunStatusService:
    """
    Service to get the run step status from run_request_logs and correlate with
    year-quarter metadata from run_management.
    """

    def __init__(self, db: Database):
        self.run_mgmt = db["run_management"]
        self.run_logs = db["run_request_logs"]

    def get_status_summary(self, tenant_id: str, engagement_id: str):
        try:
            run_doc = self.run_mgmt.find_one({"tenant_id": tenant_id, "engagement_id": engagement_id})
            if not run_doc:
                logger.warning(f"[RUN_STATUS] No run management found for tenant={tenant_id}, engagement={engagement_id}")
                return {"message": "No run data found", "status": "EMPTY", "data": []}

            metadata_entries = run_doc.get("metadata", [])
            if not metadata_entries:
                logger.warning(f"[RUN_STATUS] No metadata in run management for tenant={tenant_id}, engagement={engagement_id}")
                return {"message": "No metadata entries", "status": "EMPTY", "data": []}

            result = []

            for meta in metadata_entries:
                year = meta.get("year")
                quarter = meta.get("quarter")
                year_quarter_tag = f"{year}_Q{quarter}"

                logs_cursor = self.run_logs.find({
                    "tenant_id": tenant_id,
                    "engagement_id": engagement_id,
                    "year": year,
                    "quarter": quarter
                }).sort("created_at", -1)

                latest_log = next(logs_cursor, None)

                if not latest_log:
                    result.append({
                        "year": year,
                        "quarter": quarter,
                        "steps": self._default_pending_steps()
                    })
                    continue

                # Step info
                steps = latest_log.get("steps", [])
                step_status_dict = {step["step_name"]: step for step in steps}

                final_steps = []
                for step in StepName:
                    if step.value in step_status_dict:
                        final_steps.append({
                            "step_name": step.value,
                            "status": step_status_dict[step.value]["status"],
                            "result": step_status_dict[step.value].get("result", None),
                            "timestamp": step_status_dict[step.value].get("timestamp", None),
                            "message": step_status_dict[step.value].get("message", None)
                        })
                    else:
                        final_steps.append({
                            "step_name": step.value,
                            "status": StepStatus.PENDING,
                            "result": None,
                            "timestamp": None,
                            "message": None
                        })

                result.append({
                    "year": year,
                    "quarter": quarter,
                    "request_id": latest_log.get("request_id"),
                    "steps": final_steps
                })

            logger.info(f"[RUN_STATUS] Status summary fetched successfully for tenant={tenant_id}, engagement={engagement_id}")
            return {"message": "Success", "status": "OK", "data": result}

        except Exception as e:
            logger.exception(f"[RUN_STATUS ERROR] Failed to get run status summary: {e}")
            raise RuntimeError(f"Failed to fetch run status: {str(e)}")

    def _default_pending_steps(self):
        return [{
            "step_name": step.value,
            "status": StepStatus.PENDING,
            "result": None,
            "timestamp": None,
            "message": None
        } for step in StepName]
