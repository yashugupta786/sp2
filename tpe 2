# ingestion_service.py - Updated to support optional Tape File detection and ingestion

import uuid
from datetime import datetime
from app.model.document_schema import DocumentModel, SharePointInfoModel, StepModel
from app.model.enums import StepName, StepStatus, StepResult, IngestionStatus
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)

class SharePointIngestionService:
    """
    Service for ingesting SharePoint documents into MongoDB with metadata management.
    It updates run_documents, run_management, and sharepoint_ingestion_logs collections.
    """

    def __init__(self, db, client_id, client_secret):
        self.db = db
        self.client_id = client_id
        self.client_secret = client_secret
        self.run_management = db["run_management"]
        self.run_documents = db["run_documents"]
        self.sharepoint_logs = db["sharepoint_ingestion_logs"]

    def ingest(self, sp_client, tenant_id: str, engagement_id: str, year: str, quarter: str,
               request_id: str, use_case_name: str, is_open_source_pipeline: bool) -> Dict[str, Any]:
        """Ingest files from SharePoint folder and update MongoDB collections."""
        try:
            run_doc = self._fetch_run_metadata(tenant_id, engagement_id, request_id)
            if not run_doc:
                return {"status": StepResult.FAILED, "message": "Run management not found", "document_uploaded": False}

            run_id = run_doc.get("run_id")
            if not run_id:
                return {"status": StepResult.FAILED, "message": "Run ID not found", "document_uploaded": False}

            matched_meta = self._get_metadata_for_quarter(run_doc, year, quarter, request_id)
            if not matched_meta:
                return {"status": StepResult.FAILED, "message": "Metadata not found", "document_uploaded": False}

            all_docs, doc_run_ids = self._collect_documents(
                sp_client, matched_meta, request_id, run_id, tenant_id, engagement_id,
                int(year), quarter, use_case_name, is_open_source_pipeline
            )

            tape_doc = self._extract_tape_file(sp_client, matched_meta, request_id, run_id,
                                               tenant_id, engagement_id, int(year), quarter,
                                               use_case_name, is_open_source_pipeline)
            if tape_doc:
                all_docs.append(tape_doc)

            if all_docs:
                self.run_documents.insert_many(all_docs)
                self._mark_step_success(request_id, StepName.SHAREPOINT_INGESTION)
                self.sharepoint_logs.update_one(
                    {"request_id": request_id},
                    {"$set": {
                        "status": IngestionStatus.INGESTION_COMPLETE,
                        "doc_run_ids": list(doc_run_ids),
                        "document_uploaded": True,
                        "total_new_files": len(all_docs),
                        "completed_at": datetime.utcnow().isoformat()
                    }}
                )
                return {"status": StepResult.SUCCESS, "message": "Ingestion completed successfully", "document_uploaded": True}

            self._mark_step_failed(request_id, StepName.SHAREPOINT_INGESTION, message="No files to Ingest")
            self.sharepoint_logs.update_one(
                {"request_id": request_id},
                {"$set": {
                    "status": IngestionStatus.NO_NEW_FILES,
                    "message": "No new files found to ingest",
                    "document_uploaded": False,
                    "completed_at": datetime.utcnow().isoformat()
                }}
            )
            return {"status": StepResult.FAILED, "message": "No new files found to ingest", "document_uploaded": False}

        except Exception as e:
            logger.exception(f"[ERROR] Ingestion failed: {e}")
            self._mark_step_failed(request_id, StepName.SHAREPOINT_INGESTION, str(e))
            self._log_error(request_id, str(e))
            return {"status": StepResult.FAILED, "message": str(e), "document_uploaded": False}

    def _mark_step_success(self, request_id: str, step: StepName):
        self.sharepoint_logs.update_one(
            {"request_id": request_id, "steps.step_name": step},
            {"$set": {
                "steps.$.status": StepStatus.COMPLETED,
                "steps.$.result": StepResult.SUCCESS,
                "steps.$.timestamp": datetime.utcnow().isoformat()
            }}
        )

    def _mark_step_failed(self, request_id: str, step: StepName, message: str):
        self.sharepoint_logs.update_one(
            {"request_id": request_id, "steps.step_name": step},
            {"$set": {
                "steps.$.status": StepStatus.FAILED,
                "steps.$.result": StepResult.FAILED,
                "steps.$.timestamp": datetime.utcnow().isoformat(),
                "steps.$.message": message
            }}
        )

    def _log_error(self, request_id: str, message: str):
        self.sharepoint_logs.update_one(
            {"request_id": request_id},
            {"$set": {
                "status": IngestionStatus.ERROR,
                "message": message,
                "completed_at": datetime.utcnow().isoformat()
            }}
        )
        logger.error(f"[INGEST ERROR] {message}")

    def _extract_tape_file(self, sp_client, matched_meta, request_id, run_id,
                           tenant_id, engagement_id, year, quarter,
                           use_case_name, is_open_source_pipeline):
        year_quarter_path = matched_meta.get("year_quarter_path")
        if not year_quarter_path:
            return None

        try:
            folder = sp_client.get_folder(year_quarter_path)
            sp_client.ctx.load(folder.files)
            sp_client.ctx.execute_query()
            for file_obj in folder.files:
                if file_obj.properties["Name"].lower().startswith("tape"):
                    base64_str = sp_client.get_base64_content(file_obj)
                    if not base64_str:
                        continue
                    return DocumentModel(
                        request_id=request_id,
                        doc_run_id="TAPE_DOC",
                        run_id=run_id,
                        tenant_id=tenant_id,
                        engagement_id=engagement_id,
                        year=year,
                        quarter=quarter,
                        sub_product_type="ALL",
                        obligor_name="ALL",
                        doc_id=str(uuid.uuid4()),
                        original_filename=file_obj.properties["Name"],
                        base64=base64_str,
                        file_type=file_obj.properties["Name"].split(".")[-1],
                        use_case_name=use_case_name,
                        is_open_source_pipeline=is_open_source_pipeline,
                        sharepoint_info=SharePointInfoModel(
                            relative_path=file_obj.properties["ServerRelativeUrl"],
                            library_name="Documents",
                            site_url=sp_client.site_url
                        ),
                        steps=[
                            StepModel(
                                step_name=StepName.SHAREPOINT_INGESTION,
                                result=StepResult.SUCCESS,
                                status=StepStatus.COMPLETED,
                                timestamp=datetime.utcnow()
                            )
                        ]
                    ).dict()
        except Exception as e:
            logger.exception(f"[TAPE FILE] Extraction failed: {e}")
        return None

    # Other internal methods like _collect_documents, _get_metadata_for_quarter, _fetch_run_metadata stay the same
