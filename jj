from pymongo.collection import Collection
from datetime import datetime
from typing import Dict, Any, List
from app.model.enums import StepName, StepStatus
from app.utils.logger import setup_logger

logger = setup_logger(__name__)

class RunStatusService:
    """
    Business logic class to handle fetching the latest ingestion log entries from
    run_request_logs and return step status summaries per year-quarter combination
    defined in run_management metadata.
    """

    def __init__(self, db):
        self.run_management: Collection = db["run_management"]
        self.ingestion_logs: Collection = db["run_request_logs"]

    def get_status_summary(self, tenant_id: str, engagement_id: str) -> List[Dict[str, Any]]:
        """
        Fetches the status summary for all year-quarter metadata entries for a given
        tenant and engagement ID, based on latest available logs.

        Args:
            tenant_id (str): Tenant ID
            engagement_id (str): Engagement ID

        Returns:
            List[Dict[str, Any]]: A list of status entries per year-quarter
        """
        result = []

        try:
            logger.info(f"[RunStatusService] Fetching run_management for tenant_id={tenant_id}, engagement_id={engagement_id}")
            run_doc = self.run_management.find_one({"tenant_id": tenant_id, "engagement_id": engagement_id})

            if not run_doc or "metadata" not in run_doc:
                logger.warning(f"[RunStatusService] No run_management metadata found for tenant_id={tenant_id}, engagement_id={engagement_id}")
                return []

            metadata_entries = run_doc.get("metadata", [])

            for meta in metadata_entries:
                year = meta.get("year")
                quarter = meta.get("quarter")

                if not year or not quarter:
                    logger.warning(f"[RunStatusService] Skipping invalid metadata entry: {meta}")
                    continue

                try:
                    log_entry = self.ingestion_logs.find_one(
                        {
                            "tenant_id": tenant_id,
                            "engagement_id": engagement_id,
                            "year": year,
                            "quarter": quarter
                        },
                        sort=[("created_at", -1)]
                    )

                    steps_summary = self._build_step_status(log_entry)
                    result.append({
                        "year": year,
                        "quarter": quarter,
                        "steps": steps_summary,
                        "request_id": log_entry.get("request_id") if log_entry else None
                    })
                except Exception as sub_e:
                    logger.exception(f"[RunStatusService] Failed processing logs for {year} Q{quarter}: {str(sub_e)}")
                    result.append({
                        "year": year,
                        "quarter": quarter,
                        "steps": self._build_step_status(None),
                        "request_id": None
                    })

        except Exception as e:
            logger.exception(f"[RunStatusService] Unexpected failure while fetching status summary: {str(e)}")
            raise RuntimeError("Internal error occurred while generating status summary.")

        return result

    def _build_step_status(self, latest_log: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Builds a complete step status summary, marking missing steps as PENDING.

        Args:
            latest_log (Dict[str, Any]): Log document from MongoDB or None

        Returns:
            List[Dict[str, Any]]: Step status list
        """
        steps = latest_log.get("steps", []) if latest_log else []
        step_status_dict = {step["step_name"]: step for step in steps}

        final_steps = []

        for step in StepName:
            if step.value in step_status_dict:
                log_entry = step_status_dict[step.value]
                final_steps.append({
                    "step_name": step.value,
                    "status": log_entry.get("status", StepStatus.PENDING),
                    "result": log_entry.get("result"),
                    "timestamp": log_entry.get("timestamp"),
                    "message": log_entry.get("message")
                })
            else:
                final_steps.append({
                    "step_name": step.value,
                    "status": StepStatus.PENDING,
                    "result": None,
                    "timestamp": None,
                    "message": None
                })

        return final_steps
