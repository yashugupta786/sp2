import logging
from typing import Dict, Any
from pymongo.collection import Collection
from datetime import datetime

# Import your real ingestion service
from app.services.doc_ingest_service import DocumentIngestionService

logger = logging.getLogger(__name__)


class TextExtractionServiceSingle:
    """
    Sequential text extraction service (without threading).
    Executes DocumentIngestionService for each document one-by-one.
    """

    def __init__(self, run_documents_collection: Collection, request_logs_collection: Collection):
        """
        Initialize sequential TextExtractionService.

        :param run_documents_collection: Mongo collection for documents
        :param request_logs_collection: Mongo collection for request logs
        """
        self.run_documents_collection = run_documents_collection
        self.request_logs_collection = request_logs_collection
        self.doc_ingestion_service = DocumentIngestionService()

    def run_for_request_id(self, request_id: str):
        """
        Run text extraction sequentially for all documents under a request_id.

        :param request_id: Unique identifier for the run
        """
        logger.info(f"[TextExtractionSingle] Starting sequential extraction for request_id={request_id}")
        try:
            documents = list(self.run_documents_collection.find({"request_id": request_id}))
            if not documents:
                logger.warning(f"[TextExtractionSingle] No documents found for request_id={request_id}")
                self._update_overall_status(request_id, "SKIPPED", "No documents available for extraction")
                return

            skipped, processed, failed = 0, 0, 0

            for doc in documents:
                try:
                    payload = self._prepare_payload(doc)
                    result = self._process_single_document(doc["_id"], payload)
                    if result == "FAILED":
                        failed += 1
                    else:
                        processed += 1
                except ValueError as ve:
                    skipped += 1
                    logger.warning(f"[TextExtractionSingle] Skipped doc_id={doc.get('doc_id')}: {ve}")
                    self._update_doc_step(doc["_id"], "SKIPPED", str(ve), payload=None)
                except Exception as e:
                    failed += 1
                    logger.error(f"[TextExtractionSingle] Unexpected error for doc_id={doc.get('doc_id')}: {str(e)}")
                    self._update_doc_step(doc["_id"], "FAILED", str(e), payload=None)

            msg = f"Completed sequential extraction: Processed={processed}, Skipped={skipped}, Failed={failed}"
            overall_status = "COMPLETED" if processed > 0 else "FAILED"
            self._update_overall_status(request_id, overall_status, msg)
            logger.info(f"[TextExtractionSingle] {msg}")

        except Exception as e:
            logger.exception(f"[TextExtractionSingle] Fatal error during sequential extraction for request_id={request_id}")
            self._update_overall_status(request_id, "FAILED", str(e))

    def _prepare_payload(self, doc: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate required fields and prepare ingestion payload.

        :param doc: Mongo document
        :return: Prepared payload
        :raises ValueError: If any required field is missing
        """
        required_fields = ["doc_run_id", "doc_id", "sas_url"]
        meta_fields = ["tenant_id", "engagement_id", "sub_product_type", "obligor_name", "year", "quarter"]

        for field in required_fields:
            if not doc.get(field):
                raise ValueError(f"Missing required field: {field}")

        for field in meta_fields:
            if not doc.get(field):
                raise ValueError(f"Missing meta field: {field}")

        return {
            "doc_run_id": doc["doc_run_id"],
            "doc_id": doc["doc_id"],
            "sas_url": doc["sas_url"],
            "use_case_name": doc.get("use_case_name", "Loan File Review"),
            "is_open_source_pipeline": doc.get("is_open_source_pipeline", False),
            "doc_file_type": doc.get("doc_file_type", "pdf"),
            "meta": {
                "tenant_id": doc["tenant_id"],
                "engagement_id": doc["engagement_id"],
                "sub_product_type": doc["sub_product_type"],
                "obligor_name": doc["obligor_name"],
                "year": doc["year"],
                "quarter": doc["quarter"],
                "is_tape_file": doc.get("is_tape_file", False)
            }
        }

    def _process_single_document(self, mongo_id, payload: Dict[str, Any]) -> str:
        """
        Execute ingestion for a single document sequentially.

        :param mongo_id: Mongo _id
        :param payload: Prepared payload
        :return: "SUCCESS" or "FAILED"
        """
        try:
            logger.info(f"[TextExtractionSingle] Ingesting doc_id={payload['doc_id']}")

            result_payload = self.doc_ingestion_service.run(payload)

            if not result_payload or not isinstance(result_payload, dict):
                logger.error(f"[TextExtractionSingle] No valid output received for doc_id={payload.get('doc_id')}")
                self._update_doc_step(mongo_id, "FAILED", "No output from ingestion", payload=None)
                return "FAILED"

            if result_payload.get("doc_id") != payload.get("doc_id"):
                logger.warning(f"[TextExtractionSingle] doc_id mismatch: payload={payload.get('doc_id')} result={result_payload.get('doc_id')}")

            status = result_payload.get("status", "FAILED").strip().upper()
            if status not in ["SUCCESS", "FAILED"]:
                if "FAIL" in status:
                    status = "FAILED"
                else:
                    logger.warning(f"[TextExtractionSingle] Unexpected status received: {status}, treating as FAILED")
                    status = "FAILED"

            message = result_payload.get("message", "No message from ingestion")

            self._update_doc_step(mongo_id, status, message, payload=result_payload)

            return "SUCCESS" if status == "SUCCESS" else "FAILED"

        except Exception as e:
            logger.error(f"[TextExtractionSingle] Ingestion failed for doc_id={payload.get('doc_id')}: {str(e)}")
            self._update_doc_step(mongo_id, "FAILED", str(e), payload=None)
            return "FAILED"

    def _update_doc_step(self, mongo_id, status: str, message: str, payload: Dict[str, Any] = None):
        """
        Update TEXT_EXTRACTION step for a document in run_documents.

        :param mongo_id: Document Mongo _id
        :param status: Step status
        :param message: Step message
        :param payload: Optional response payload
        """
        try:
            update_obj = {
                "steps.TEXT_EXTRACTION.status": status,
                "steps.TEXT_EXTRACTION.timestamp": datetime.utcnow().isoformat(),
                "steps.TEXT_EXTRACTION.message": message
            }
            if payload:
                update_obj["steps.TEXT_EXTRACTION.response_payload"] = payload

            result = self.run_documents_collection.update_one(
                {"_id": mongo_id},
                {"$set": update_obj}
            )
            if result.modified_count == 0:
                logger.warning(f"[TextExtractionSingle] No document updated for mongo_id={mongo_id}")

        except Exception as e:
            logger.error(f"[TextExtractionSingle] Mongo update failed for mongo_id={mongo_id}: {str(e)}")

    def _update_overall_status(self, request_id: str, status: str, message: str):
        """
        Update overall TEXT_EXTRACTION step for the request.

        :param request_id: Request identifier
        :param status: Step status
        :param message: Step message
        """
        try:
            result = self.request_logs_collection.update_one(
                {"request_id": request_id, "steps.step_name": "TEXT_EXTRACTION"},
                {"$set": {
                    "steps.$.status": status,
                    "steps.$.timestamp": datetime.utcnow().isoformat(),
                    "steps.$.message": message
                }}
            )
            if result.modified_count == 0:
                logger.warning(f"[TextExtractionSingle] No request log updated for request_id={request_id}")

        except Exception as e:
            logger.error(f"[TextExtractionSingle] Mongo update failed for request_id={request_id}: {str(e)}")
