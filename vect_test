from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from typing import Dict, Any, List
from pymongo.collection import Collection
from app.services.doc_vectorization_service import DocumentVectorizationService
from app.common.enums import StepName, StepResult, StepStatus
from app.config.logging_config import logger

class VectorizationService:
    def __init__(self, run_documents_collection: Collection, request_logs_collection: Collection, max_workers: int = 4):
        self.run_documents_collection = run_documents_collection
        self.request_logs_collection = request_logs_collection
        self.max_workers = max_workers
        self.doc_vector_service = DocumentVectorizationService()

    def run_for_request_id(self, request_id: str):
        """
        Run vector indexing (vectorization) in parallel for all documents under a given request ID.
        Only proceeds for documents where TEXT_EXTRACTION step was successful.
        """
        logger.info(f"[Vectorization] Starting vectorization for request_id={request_id}")
        try:
            documents = list(self.run_documents_collection.find({"request_id": request_id}))
            valid_docs = [doc for doc in documents if self._should_vectorize(doc)]

            if not valid_docs:
                msg = "No documents with successful TEXT_EXTRACTION found. Skipping vectorization."
                logger.warning(f"[Vectorization] {msg}")
                self._update_overall_status(request_id, StepResult.SKIPPED, msg)
                return

            skipped = processed = failed = 0
            futures = {}

            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                for doc in valid_docs:
                    doc_id = doc.get("_id")
                    try:
                        payload = self._prepare_payload(doc)
                        future = executor.submit(self._process_single_document, doc_id, payload)
                        futures[future] = doc_id
                    except ValueError as ve:
                        skipped += 1
                        logger.warning(f"[Vectorization] Skipped doc_id={doc.get('doc_id')}: {ve}")
                        self._update_doc_step(doc_id, StepResult.SKIPPED, str(ve), payload=None)

                for future in as_completed(futures):
                    doc_id = futures[future]
                    try:
                        result = future.result()
                        if result == "FAILED":
                            failed += 1
                        else:
                            processed += 1
                    except Exception as e:
                        failed += 1
                        logger.error(f"[Vectorization] Future error for doc_id={doc_id}: {str(e)}")
                        self._update_doc_step(doc_id, StepResult.FAILED, str(e), payload=None)

            msg = f"Completed vectorization: Processed={processed}, Skipped={skipped}, Failed={failed}"
            logger.info(f"[Vectorization] {msg}")
            overall_status = StepResult.SUCCESS if processed > 0 and failed == 0 else StepResult.FAILED
            self._update_overall_status(request_id, overall_status, msg)

        except Exception as e:
            logger.exception(f"[Vectorization] Fatal error during vectorization for request_id={request_id}: {str(e)}")
            self._update_overall_status(request_id, StepResult.FAILED, str(e))

    def _should_vectorize(self, doc: Dict[str, Any]) -> bool:
        for step in doc.get("steps", []):
            if step.get("step_name") == StepName.TEXT_EXTRACTION and step.get("result") == StepResult.SUCCESS:
                return True
        return False

    def _prepare_payload(self, doc: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate and prepare vectorization payload from document.
        Raises ValueError if required fields are missing.
        """
        required_fields = ["doc_run_id", "doc_id", "sas_url"]
        meta_fields = ["tenant_id", "engagement_id", "sub_product_type", "obligor_name", "year", "quarter"]

        for field in required_fields:
            if not doc.get(field):
                raise ValueError(f"Missing required field: {field}")
        for field in meta_fields:
            if not doc.get(field):
                raise ValueError(f"Missing meta field: {field}")

        return {
            "doc_run_id": doc["doc_run_id"],
            "doc_id": doc["doc_id"],
            "sas_url": doc["sas_url"],
            "use_case_name": doc.get("use_case_name", "Loan File Review"),
            "is_open_source_pipeline": doc.get("is_open_source_pipeline", False),
            "doc_file_type": doc.get("doc_file_type", "pdf"),
            "meta": {
                "tenant_id": doc["tenant_id"],
                "engagement_id": doc["engagement_id"],
                "sub_product_type": doc["sub_product_type"],
                "obligor_name": doc["obligor_name"],
                "year": doc["year"],
                "quarter": doc["quarter"],
                "is_tape_file": doc.get("is_tape_file", False)
            }
        }

    def _process_single_document(self, mongo_id, payload: Dict[str, Any]) -> str:
        try:
            logger.info(f"[Vectorization] Vectorizing doc_id={payload['doc_id']}")
            result_payload = self.doc_vector_service.run_vectorization(facility_payload=payload)

            if not result_payload or not isinstance(result_payload, dict):
                raise ValueError("Invalid response from vectorization service")

            if result_payload.get("doc_id") != payload.get("doc_id"):
                raise ValueError("doc_id mismatch in response")

            status = result_payload.get("status", "FAILED").strip().upper()
            if status not in ["SUCCESS", "FAILED"]:
                status = "FAILED"

            final_result = StepResult.SUCCESS if status == "SUCCESS" else StepResult.FAILED
            message = result_payload.get("message", "No message from vectorization")

            self._update_doc_step(mongo_id, final_result, message, result_payload)
            return "SUCCESS" if final_result == StepResult.SUCCESS else "FAILED"

        except Exception as e:
            logger.error(f"[Vectorization] Vectorization failed for doc_id={payload.get('doc_id')}: {str(e)}")
            self._update_doc_step(mongo_id, StepResult.FAILED, str(e), payload=None)
            return "FAILED"

    def _update_doc_step(self, mongo_id, step_result: str, message: str, payload: Dict[str, Any] = None):
        try:
            step_status = StepStatus.COMPLETED if step_result == StepResult.SUCCESS else StepStatus.FAILED
            update_obj = {
                "steps.$[step].result": step_result,
                "steps.$[step].status": step_status,
                "steps.$[step].timestamp": datetime.utcnow().isoformat(),
                "steps.$[step].message": message,
            }
            if payload:
                update_obj["steps.$[step].response_payload"] = payload

            result = self.run_documents_collection.update_one(
                {"_id": mongo_id},
                {"$set": update_obj},
                array_filters=[{"step.step_name": StepName.VECTOR_INDEXING}]
            )

            if result.modified_count == 0:
                logger.warning(f"[Vectorization] No VECTOR_INDEXING step found, pushing new one for mongo_id={mongo_id}")
                insert_step = {
                    "step_name": StepName.VECTOR_INDEXING,
                    "result": step_result,
                    "status": step_status,
                    "timestamp": datetime.utcnow().isoformat(),
                    "message": message
                }
                if payload:
                    insert_step["response_payload"] = payload

                self.run_documents_collection.update_one(
                    {"_id": mongo_id},
                    {"$push": {"steps": insert_step}}
                )
            else:
                logger.info(f"[Vectorization] Step updated for mongo_id={mongo_id}")
        except Exception as e:
            logger.error(f"[Vectorization] Failed to update document step for mongo_id={mongo_id}: {str(e)}")

    def _update_overall_status(self, request_id: str, step_result: str, message: str):
        try:
            step_status = StepStatus.COMPLETED if step_result == StepResult.SUCCESS else StepStatus.FAILED
            update_obj = {
                "steps.$[step].result": step_result,
                "steps.$[step].status": step_status,
                "steps.$[step].timestamp": datetime.utcnow().isoformat(),
                "steps.$[step].message": message,
            }

            result = self.request_logs_collection.update_one(
                {"request_id": request_id},
                {"$set": update_obj},
                array_filters=[{"step.step_name": StepName.VECTOR_INDEXING}]
            )

            if result.modified_count == 0:
                logger.warning(f"[Vectorization] No VECTOR_INDEXING step found in request_logs. Pushing new step for request_id={request_id}")
                insert_step = {
                    "step_name": StepName.VECTOR_INDEXING,
                    "result": step_result,
                    "status": step_status,
                    "timestamp": datetime.utcnow().isoformat(),
                    "message": message
                }
                self.request_logs_collection.update_one(
                    {"request_id": request_id},
                    {"$push": {"steps": insert_step}}
                )
            else:
                logger.info(f"[Vectorization] Overall VECTOR_INDEXING step updated for request_id={request_id}")
        except Exception as e:
            logger.error(f"[Vectorization] Failed to update overall step for request_id={request_id}: {str(e)}")
